The first rule is, **do not** fork this repo, clone it or use it as template.

The second rule is, **do not** fork this repo, clone it or use it as template.

Good luck! ðŸ”¥

# Weglot JS Assessment

## Technical skills (~1h)

Vous devez souvent organiser des rÃ©unions de 60 minutes avec vos collÃ¨gues,
seulement tout le monde a un emploi du temps trÃ¨s chargÃ©. Google agenda vous
donne les indisponibilitÃ©s de tout le monde, pourquoi ne pas faire en sorte de
trouver Ã§a automatiquement ?

### Format des donnÃ©es

Vous trouverez les donnÃ©es dans le dossier data.

**EntrÃ©e**

Chaque ligne est une plage horaire indisponible, au format `d hh:mm-hh:mm`.

`d` est le numÃ©ro du jour de la semaine (1 Ã  5, lundi au vendredi).

`hh:mm-hh:mm` est la plage horaire de ce jour, dÃ©but et fin incluses.

Les horaires de travail sont du lundi au vendredi de 08:00 Ã  17:59. Tous les
crÃ©neaux indisponibles y sont inclus.

**Sortie**

Une ligne au format `d hh:mm-hh:mm` correspondant Ã  l'horaire de rÃ©union trouvÃ©.
Il doit Ãªtre:

- en intersection avec aucun crÃ©neau d'indisponibilitÃ© d'un collÃ¨gue
- pendant les horaires de travail, sans dÃ©passer
- d'une durÃ©e exacte de 60 minutes, dÃ©but et fin incluses (eg. 14:00-14:59)
- la premiÃ¨re solution possible s'il en existe plusieurs

**Exemple**

Pour l'entrÃ©e :

```
1 08:45-12:59
3 11:09-11:28
5 09:26-09:56
5 16:15-16:34
3 08:40-10:12
```

La solution est

```
1 13:00-13:59
```

Le premier jour il n'y a qu'un seul crÃ©neau indisponible de 08:45 Ã  12:59. En
faisant par exemple commencer la rÃ©union Ã  13:00 et en la terminant Ã  13:59, elle
n'aura aucune intersection avec les crÃ©neaux indisponibles.

### Environnement

Vous travaillez avec Node.js v12.18.4

### Tests

CrÃ©ez un test avec une librairie adÃ©quate en prenant les _inputX.txt_ en entrÃ©e
pour vÃ©rifier que le rÃ©sultat de votre fonction correspond aux sorties attendues
dans les _outputX.txt_ dans le dossier data.

### DÃ©ploiement

Envoyez votre solution sur un repo git accessible sur Github ou Gitlab puis
envoyez nous le lien de ce repo, avec l'accÃ¨s si nÃ©cessaire.

### Bonus

1. Vous prÃ©fÃ©rez avoir un code standardisÃ© ? Nous aussi. Ajoutez votre
   config prÃ©fÃ©rÃ©e.

2. CrÃ©ez une config CI pour exÃ©cuter la commande test sur votre repo Ã  chaque
   modification.

---

## Code review (~20m)

Passez en revue le code ci dessous

Si vous pensez que des modifications sont utiles
1. Ã©crivez un commentaire comme pendant une review de pull request
2. puis Ã©crivez le code comme vous l'imagineriez

**NB**

- Faites ces reviews comme bon vous semble, tout n'est pas Ã  commenter
- Ne commentez pas le style (indentation, trailing comma, etc.)
- Admettez que le code fonctionne
- Ces bouts de codes fictifs n'ont rien Ã  voir les uns avec les autres
- Ne vous attardez pas sur des dÃ©tails, comme le naming, qui ne nous intÃ©ressent pas ici

1.

```js
const data = [
  { value: "1", label: "One" },
  { value: "2", label: "Two" },
  { value: "3", label: "Three" },
];

const values = data.reduce((values, { value }) => { // using a map function would be simpler
  values.push(value);
  return values;
}, []);
```
Suggestion:
```js
const values = data.map(element => element.value);
```

2.

```js
async function getIndexes() {
   return await fetch('https://api.coingecko.com/api/v3/indexes').then(res => res.json());

async function analyzeIndexes() {
   const indexes = await getIndexes().catch(_ => { // I find it more readable tu use try-catch wih async-await
      throw new Error('Unable to fetch indexes');
   });
   return indexes;
}
```
Suggestion
```js
async function analyzeIndexes() {
   try {
      return await getIndexes()
   }
   catch(_) {
      throw new Error('Unable to fetch indexes');
   }
}
```

3.

```js
let state; // since state isn't redefined, you can afford to use a const here and remove the else condition
const user = getUser();
if (user) {
   const project = getProject(user.id);
   state = {
      user,
      project
   };
} else {
   state = {
      user: null,
      project: null
   };
}
ctx.body = state;
```
Suggestion
```js
const state = {
      user: null,
      project: null
   };
const user = getUser();
if (user) {
   const project = getProject(user.id);
   state = {
      user,
      project
   };
}
ctx.body = state
```


4.

```js
function getQueryProvider() {
  const url = window.location.href;
  const [_, provider] = url.match(/provider=([^&]*)/); // is the regexp match returns null, it is not decomposable. However if it is an array, you can return its second element anyway, weather defined or not, you'd still have the same function
  if (provider) {
     return provider;
  }
  return;
}
```
Suggestion
```js
function getQueryProvider() {
  const url = window.location.href;
  const matchingProviders = url.match(/provider=([^&]*)/);
  if (matchingProviders) {
     return matchingProviders[1];
  }
}
```

5.

```js
function getParagraphTexts() {
   const texts = [];
   document.querySelectorAll("p").forEach(p => { // If it is legit to quote some sources found on the net, I've found the following link this on the topic, so basically in a IE free environment, you can use Array.from() (https://gomakethings.com/converting-a-nodelist-to-an-array-with-vanilla-javascript/)
      texts.push(p);
   });
   return texts;
}
```
Suggestion
```js
function getParagraphTexts() {
   return Array.from(document.querySelectorAll("p"))
}
```

6.

```js
function Employee({ id }) {
   const [error, setError] = useState(null);
   const [loading, setLoading] = useState(true);
   const [employee, setEmployee] = useState({});

   useEffect(() => { // I don't know how this state system is supposed to work, but it seems like it could deserve some asynchronous support.
      getEmployee(id)
         .then(employee => {
            setEmployee(employee);
            setLoading(false);
         })
         .catch(_ => {
            setError('Unable to fetch employee');
            setLoading(false);
         });
   }, [id]);

   if (error) {
      return <Error />;
   }

   if (loading) {
      return <Loading />;
   }

   return ( // It could be done using a loop of some sort, and some verification on undefined values (cf suggestion if it suits yor taste).
      <Table>
         <Row>
            <Cell>{employee.firstName}</Cell>
            <Cell>{employee.lastName}</Cell>
            <Cell>{employee.position}</Cell>
            <Cell>{employee.project}</Cell>
            <Cell>{employee.salary}</Cell>
            <Cell>{employee.yearHired}</Cell>
            <Cell>{employee.wololo}</Cell>
         </Row>
      </Table>
   );
}
```
Suggestion
```js
const displayableEmployeeProperties=["firstName", "lastName", "position", "project", "salary", "yearHired", "wololo"]
return `
   <Table>
      <Row>
         ${displayableEmployeeProperties.reduce((acc, property) => {
            if (employe.hasOwnProperty(property)){
               acc.concat(`<Cell>${employee[property]}</Cell>\n`)
            }
            return acc
         },"")}
      </Row>
   </Table>
   `
```

7.

```js
async function getFilledIndexes() {
   try {
      const filledIndexes = [];
      const indexes = await getIndexes();
      const status = await getStatus();
      const usersId = await getUsersId();

      for (let index of indexes) { // assumig indexes is an array, you can use a filter
         if (index.status === status.filled && usersId.includes(index.userId)) {
            filledIndexes.push(index);
         }
      }
      return filledIndexes;
   } catch(_) {
      throw new Error ('Unable to get indexes');
   }
}
```
Suggestion
```js
const filledIndexes = indexdes.filter(index =>  (index.status === status.filled && usersId.includes(index.userId)) )
```

8.

```js
function getUserSettings(user) {
   if (user) {
      const project = getProject(user.id);
      if (project) {
         const settings = getSettings(project.id); // it's a bit heavy but without further context, a bit hard to improve, multiple condition could call for return first or ternaries but right here it would only make the expression more heavy... so I'm a bit dry on this one
         if (settings) {
            return settings;
         }
      }
   }
   return {};
}
```